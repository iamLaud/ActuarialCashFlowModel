# -*- coding: utf-8 -*-
"""
Created on Wed May 31 15:43:33 2017

@author: Laurent DEBRIL
Date of last revision: August 1st 2017

"""

#--------------------------------------------------
#           Python packages
#--------------------------------------------------
import numpy as np
import pandas as pd
import time, gc, sys
MY_PATH = r'C:\Users\FR015797\Documents\PyALM_gen\code\alm'
sys.path.append(MY_PATH + r'\balancesheet\assets') #the directory that contains my classes
sys.path.append(MY_PATH + r'\balancesheet\assets\asset') 
sys.path.append(MY_PATH + r'\balancesheet\assets\esglinker') 
sys.path.append(MY_PATH + r'\balancesheet\liabilities') 
sys.path.append(MY_PATH + r'\balancesheet\liabilities\liability') 
sys.path.append(MY_PATH + r'\wealthstream') 
sys.path.append(MY_PATH + r'\rule') 
sys.path.append(MY_PATH + r'\hmi')
#--------------------------------------------------
#           Project packages import
#--------------------------------------------------
from Assets import Assets, Bond, Equity, Cash
from Liabilities import Liabilities, Liability
from WealthStream import WealthStream
from ALM_HMI import ALM_HMI
from ESGLinker import ESGLinker
from Rule import Rule
#--------------------------------------------------
#       Start of the proper code
#--------------------------------------------------

class ALMComputer(object):
    """
        This class is the core of the simulator and builds the bridge
        between the different parts of the code.
    """
    def __init__(self, time_horizon=50, nb_simulation=1000):
#        --------- SIMULATION PARAMETERS -------------------
        self.nb_simulation = nb_simulation
        self.time_horizon = time_horizon
#        self.rules = Rule(time_horizon=time_horizon) # Management rules
#        ---------- INITIALIZATION ------------------------
        self.generator = ESGLinker() # used to import data from the ESG
        self.setTraj()
        self.setWS()
#        ----------- INDICATORS ----------------------------
        self.bel = 0.
        self.vif = 0.
        self.scr = 0.
        self.mcr = 0.

    def simulatePeriod(self, current_step):
        self.updateStart(current_step)
        self.updateMid(current_step)
        self.updateEnd(current_step)

    def balance(self, current_step, outside_stream=0):
        """
            we batch buy or sell to reduce the number of ops on our portfolios
        """
        if(current_step in range(1, self.time_horizon)):
            liab_value = self.liabilities.computeValAll().loc[current_step, 'Liabilities Value']
            # here liab_value only takes into account the Mathematical Provision, MP,(no CapRes or other Res/Prov)
            asset_value = self.assets.computePortfolioVal().loc[current_step, 'Portfolio Book Value']
            # here asset_value is the total Market Val of our Assets portfolio
            balance = asset_value - liab_value
            balance += outside_stream
            if(balance>0):
                self.assets._decrease_(amount=balance, current_step=current_step+1, asset_type='Bond')
                # if the balance is positive i.e. we got too many assets, we sell some
            elif(balance<0):
                self.assets._increase_(amount=abs(balance), current_step=current_step+1, asset_type='Bond')
                # on the contrary, we buy some assets if we got too many liabilities (i.e. math provision)

    def updateStart(self, current_step):
        # ------- ASSETS ------------
        self.assets.update(current_step=current_step,                   \
                           current_yield=self.bond_info.loc[:, 'RRate'],\
                           spreads=self.bond_info.loc[:, 'Spreads'],    \
                           cash_flows=self.cash_flows,                  \
                           statement=self.statement)
        # on met Ã  jour le bilan Actifs-Passif
        # ------- LIABILITIES -------
        flag = self.liabilities.update(current_step=current_step,       \
                                       cash_flows=self.cash_flows,      \
                                       available_wealth=self.available_wealth.value,\
                                       mode='mid')
        #-------- CORRESPONDANCE ASSET - LIABILITIES ----------
        buffer = flag[1] - flag[0]
#        print('BUFFER = ', buffer)
        if(flag[0] != 0):
            err = buffer/flag[0]*100
        else:
            err = 0
        # flag[0] is the CF_in generated by the update of the Liability portfolio at t = current_step
        # flag[1] is the CF_out generated by the update of the Liability portfolio at t = current_step
        if(current_step in range(1, self.time_horizon) and err>.01):
            self.balance(current_step=current_step, outside_stream=buffer)
        self.setWS()

    def updateMid(self, current_step):
        # ------- LIABILITIES -------
        self.liabilities.update(current_step=current_step,      \
                                       cash_flows=self.cash_flows,     \
                                       available_wealth=self.available_wealth.value,\
                                       mode='end')
        # on MaJ les passifs
        # on cherche a servir les taux en appelant les differents leviers -- appeler la fonction computeRate de la classe Rate ici
        # toutes les classes de Rate seront appelees ici et interagiront avec les WealthStreams
        if(current_step in range(1, self.time_horizon)):
            self.balance(current_step=current_step)
        self.available_wealth.computeWealth()

#        self.rules.managePS(current_step=current_step, assets=self.assets, \
#                            liabilities=self.liabilities, min_wealth=self.min_wealth, \
#                            max_wealth=self.max_wealth,\
#                            statement=self.statement)
        self.setWS()

    def updateEnd(self, current_step):
        # on alloue les provisions et les benefices + marges
        # reallocation et rebalancement
        self.available_wealth.computeWealth()
#        self.balance(current_step=current_step)
        if(current_step in range(1, self.time_horizon)):
            self.assets._rebalance_(current_step)
        self.setWS()

    def setWS(self):
        """
            initializes our set of WealthStream used during our simulation
        """
        self.available_wealth = WealthStream(time_horizon=self.time_horizon)

        for e in self.assets.portfolio:
            self.available_wealth.add(e.value.loc[:, 'Market Value'])
        self.math_prov = WealthStream(time_horizon=self.time_horizon)

        for e in self.liabilities.math_provision:
            self.math_prov.add(e.value.loc[:, 'Contract Value'])

        pgl = self.assets.computePortfolioPGL()

        self.potential_gain = WealthStream(time_horizon=self.time_horizon)
        self.potential_gain.add(pgl.iloc[:, 1])

        self.potential_loss = WealthStream(time_horizon=self.time_horizon)
        self.potential_loss.substract(abs(pgl.iloc[:, 2]))

        self.net_potential_gain = self.potential_gain + self.potential_loss
        self.net_wealth = self.available_wealth + self.net_potential_gain
        self.max_wealth = self.available_wealth + self.potential_gain
        self.min_wealth = self.available_wealth + self.potential_loss

#    def updateWS(self):
#        for i in self.available_wealth.pluses:
#            for j in self.assets.portfolio:
#                if(id(i) != id(j.value.loc[:, 'Market Value'])):
#                    self.available_wealth.add(j.value.loc[:, 'Market Value'])
#        for i in self.math_prov.pluses:
#            for j in self.liabilities.math_provision:
#                if(id(i) != id(j.value.loc[:, 'Contract Value'])):
#                    self.available_wealth.add(j.value.loc[:, 'Contract Value'])

    def setTraj(self):
        self.assets = Assets(nb_bond=1, nb_equity=1, nb_cash=1, \
                             ratio={'Bond':.7, 'Equity':.2, 'Cash':.1},\
                             wealth = 1000, time_horizon=self.time_horizon)
        self.liabilities = Liabilities(cap_reserve=None, math_provision=None,\
                                       own_funds=None, profit_shar_prov=None,\
                                       eligib_prov=None, time_horizon=self.time_horizon)
        self.cash_flows = pd.DataFrame(data=0, index=np.arange(1,self.time_horizon+1), columns=['CF_in', 'CF_out'])
#       --------------------------------------------------------------------
        noise = np.random.normal(0, .001, size=30) # bruit blanc de variance 1 bp sur les taux a maturite 30 ans
        USrate = (np.asarray([1.22,	1.35,	1.51,	1.65,	1.78,	1.89,	1.98,	2.06,	2.13,	2.19,	2.24,	2.29,\
                              2.33,	2.37,	2.41,	2.45,	2.49,	2.53,	2.56,	2.60,	2.63,	2.67,	2.70,	2.73,	2.77,\
                              2.80, 2.83,	 2.86,	2.89,	2.91])/100 + noise/100).transpose() # courbe des taux US T-Bonds
        self.bond_info = pd.DataFrame(data=0, index=np.arange(1,len(USrate)+1), columns=['RRate', 'Spreads'])
        self.bond_info.loc[:, 'RRate'] = USrate
        self.bond_info.loc[:, 'Spreads'] = np.random.normal(0, 0, size=30)
#       --------------------------------------------------------------------
        self.statement = pd.DataFrame(data=0, index=np.arange(1,self.time_horizon+1),\
                                      columns=['financial_income', 'margin', 'benefits', 'tech_income', 'admin_income'])


#-----------  MAIN OF THE PROGRAM -----------------------
    def main():
#       ------------------- DYNAMIC RAM CLEANING ---------------------
        gc.enable()
        # --------- TIME STAMPING ------------------------------------
        start_time = time.time()
        # ---------------------------------------------------------
        simulator = ALMComputer(time_horizon=50, nb_simulation=50)
        hmi = ALM_HMI(simulator) # we pair the simulator and the HMI

        for k in range(1, simulator.nb_simulation+1):
            # reinitialiser les variables a chaque nouvelle simulation
            for t in range(1, simulator.time_horizon+1):
                simulator.simulatePeriod(t)
            print("Trajectory #", k)

#           ----------- WE SAVE THE VARIABLES WE WANT AT THE END OF EACH TRAJECTORY PROJECTION
            if(k == 1):
                hmi.save(ALM=simulator, exists=False, var_name='available_wealth')
                hmi.save(ALM=simulator, exists=False, var_name='math_prov')
                hmi.save(ALM=simulator, exists=False, var_name='potential_gain')
                hmi.save(ALM=simulator, exists=False, var_name='potential_loss')
                hmi.save(ALM=simulator, exists=False, var_name='net_potential_gain')
                hmi.save(ALM=simulator, exists=False, var_name='max_wealth')
                hmi.save(ALM=simulator, exists=False, var_name='min_wealth')
                hmi.save(ALM=simulator, exists=False, var_name='net_wealth')
                hmi.saveDF(ALM=simulator, exists=False, var_name='cash_flows')
                hmi.saveDF(ALM=simulator, exists=False, var_name='statement')
#                hmi.saveDict(ALM=simulator, exists=False, var_name1='liabilities', var_name2='other_provisions')
            else:
                hmi.save(ALM=simulator, exists=True, var_name='available_wealth')
                hmi.save(ALM=simulator, exists=True, var_name='math_prov')
                hmi.save(ALM=simulator, exists=True, var_name='potential_gain')
                hmi.save(ALM=simulator, exists=True, var_name='potential_loss')
                hmi.save(ALM=simulator, exists=True, var_name='net_potential_gain')
                hmi.save(ALM=simulator, exists=True, var_name='max_wealth')
                hmi.save(ALM=simulator, exists=True, var_name='min_wealth')
                hmi.save(ALM=simulator, exists=True, var_name='net_wealth')
                hmi.saveDF(ALM=simulator, exists=True, var_name='cash_flows')
                hmi.saveDF(ALM=simulator, exists=True, var_name='statement')
#                hmi.saveDict(ALM=simulator, exists=False, var_name1='liabilities', var_name2='other_provisions')

            simulator.setTraj()

#        actualiser la somme de bel, vif, scr et mcr ici
        simulator.bel /= simulator.nb_simulation
        simulator.vif /= simulator.nb_simulation
        simulator.scr = None
        simulator.mcr = None

#       -------------- INFO SCREEN DISPLAY -----------------
        duration = time.time() - start_time
        hmi.display(nb_simulation=simulator.nb_simulation, time_horizon=simulator.time_horizon, duration=duration)
        # we display some information from the simulation onto the screen


    if __name__ == "__main__":
        main()
