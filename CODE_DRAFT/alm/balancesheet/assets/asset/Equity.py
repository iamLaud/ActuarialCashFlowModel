# -*- coding: utf-8 -*-
"""
Created on Thu May 18 10:01:38 2017

@author: FR015797
Date of last revision: August 1st 2017
"""


#--------------------------------------------------
#           Project packages
#--------------------------------------------------
from Asset import Asset
#--------------------------------------------------
#           Python packages
#--------------------------------------------------
import pandas as pd
import numpy as np
#--------------------------------------------------
#       Start of the proper code
#--------------------------------------------------

class Equity(Asset):
    """
        represents Equity-like instruments. 
        
        This class inherited from the *Asset* class
        
        :param value: Time serie of the value of the Equity over time
        :param time_horizon: Duration of the simulation
        :param starting_point: Point of time in the simulation when the instrument is emitted
        :param flag: hidden variables equal to 0 by default
        :param return_rate: Time serie of the value of the interest rate of the Equity over time
        :param potential: Time serie of the potential gain & loss on the Equity
        :type value: DataFrame of Float
        :type time_horizon: Integer
        :type starting_point: Integer
        :type flag: Float
        :type return_rate: DataFrame of Float
        :type potential: DataFrame of Float
        :return: An instance of the Equity class
        :rtype: Equity object
    """
    def __init__(self, value=1, return_rate=.08, time_horizon=50, starting_point=1):
        """
            creates an Equity object
        """
        self.starting_point = starting_point
        self.time_horizon = time_horizon
        self.flag = 0

        # Initialisation du return_rate
        self.return_rate = pd.DataFrame(data=0, index=np.arange(1,time_horizon+1), columns=['RRate'])
        self.return_rate.loc[self.starting_point:self.time_horizon, 'RRate'] = return_rate
        # ligne suivante temporaire pour phase de coding/testing:
        self.return_rate.loc[self.starting_point:self.time_horizon, 'RRate'] = np.random.normal(.08, .12, size=self.time_horizon-self.starting_point+1 )
        # Initialisation de value
        self.value = pd.DataFrame(data=value, index=np.arange(1,time_horizon+1), columns=['Market Value', 'Book Value'])
        self.value.loc[:starting_point-1, 'Book Value'] = 0
        self.value.loc[:starting_point-1, 'Market Value'] = 0
        # Initialisation des PGL
        self.potential = pd.DataFrame(data=0, index=np.arange(1,time_horizon+1), columns=['Potential Gain', 'Potential Loss'])
        self.computePotential()         

    def cashOut(self, current_step):
        """
            cashes out the amount of money generated by the Equity
        """
        output = {}
        output['all'] = self.value.loc[current_step, 'Market Value']
        output['pnl'] = self.value.loc[current_step, 'Market Value'] - self.value.loc[current_step, 'Book Value']
        if(current_step<self.time_horizon):
            self.value.loc[np.arange(current_step+1,self.time_horizon+1), 'Market Value'] = 0
            self.value.loc[np.arange(current_step+1,self.time_horizon+1), 'Book Value'] = 0
        self.computePotential()
        return output    
   
    def sell(self, amount, current_step):
        self.computePotential()
        denom = 1 + (self.potential.loc[current_step, 'Potential Gain'] \
                     + self.potential.loc[current_step, 'Potential Loss']) * 1/self.value.loc[current_step, 'Market Value']
        real_amount = amount/denom
        ratio = real_amount/self.value.loc[current_step, 'Market Value']
        if(ratio <= 1):
            # valeur nettee des PMVL au pro rata
            self.value.loc[current_step:self.time_horizon, 'Market Value'] -= ratio \
                * self.value.loc[current_step, 'Market Value'] 
            self.value.loc[current_step:self.time_horizon, 'Book Value'] -= ratio \
                * self.value.loc[current_step, 'Book Value']
            
#            if(self.value.loc[current_step, 'Market Value'] == 0):
#                self.value.loc[current_step:self.time_horizon, 'Book Value'] = 0            
        self.computePotential()
        return amount
        
    def getWealth(self, current_step):
        """
            returns the amount of money represented by the Equity at a certain point in time
        """
        return (self.value.loc[current_step, 'Market Value'])

    def getWealthPlus(self, current_step):
        """
            returns the wealth returned by the selling of the Equity increased by the potential gain on it
        """
        return self.getWealth(current_step) + self.potential.loc[current_step, 'Potential Gain']
        
    def getWealthMinus(self, current_step):
        """
            returns the wealth returned by the selling of the Equity decreased by the potential loss on it
        """
        return self.getWealth(current_step) + self.potential.loc[current_step, 'Potential Loss']
#   
    def computePotential(self):
        """
            updates the potential gains & losses on this Equity
        """
        self.potential["Potential Gain"] = np.where(self.value.loc[:, 'Market Value'] - self.value.loc[:, 'Book Value'] >0, \
                      (self.value.loc[:, 'Market Value'] - self.value.loc[:, 'Book Value']), 0)
        self.potential["Potential Loss"] = np.where(self.value.loc[:, 'Market Value'] - self.value.loc[:, 'Book Value'] <0, \
                      (self.value.loc[:, 'Market Value'] - self.value.loc[:, 'Book Value']), 0)

    def updateValue(self, current_step):
        """
            capitalizes the Equity over a period of time
        """
        # no dividend hypothesis
        # non amortizable Asset type i.e. Book Value doesn't decrease over time
        # Market Value updating only
        res = self.value.loc[current_step, 'Market Value'] 
        self.value.loc[current_step:self.time_horizon, 'Market Value'] = self.value.loc[current_step, 'Market Value'] * (1 + self.return_rate.loc[current_step, 'RRate'])
        res = self.value.loc[current_step, 'Market Value'] - res
        return res
        
    def update(self, current_step, current_yield=None, spreads=None):
        """
            updates the Equity over a period of time
        """
        res = 0
        if(current_step>=self.starting_point):
            res = self.updateValue(current_step)
        return res

    def __str__(self):
        return (self.value['Market Value']).__str__()

#--------------------------------------------------
#       Start of the testing part of the code
#--------------------------------------------------

#def main():
#    import gc
#    gc.enable()
#    
#    equity = Equity(value=100)
#    for t in range(1, equity.time_horizon+1):
#        equity.update(t)
#    equity.computePotential()    
#    print(equity.potential)
#
#    
#if __name__ == "__main__":
#    main()
    