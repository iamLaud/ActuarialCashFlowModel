# -*- coding: utf-8 -*-
"""
Created on Thu May 18 10:01:38 2017

@author: FR015797
Date of last revision: May 18th 2017
"""


#--------------------------------------------------
#           Project packages
#--------------------------------------------------
from Asset import Asset
#--------------------------------------------------
#           Python packages
#--------------------------------------------------
import pandas as pd
import numpy as np
#--------------------------------------------------
#       Start of the proper code
#--------------------------------------------------

class Equity(Asset):
    """
        represents Equity-like instruments. 
        
        This class inherited from the *Asset* class
        
        :param value: Time serie of the value of the Equity over time
        :param time_horizon: Duration of the simulation
        :param starting_point: Point of time in the simulation when the instrument is emitted
        :param flag: hidden variables equal to 0 by default
        :param return_rate: Time serie of the value of the interest rate of the Equity over time
        :param potential: Time serie of the potential gain & loss on the Equity
        :type value: DataFrame of Float
        :type time_horizon: Integer
        :type starting_point: Integer
        :type flag: Float
        :type return_rate: DataFrame of Float
        :type potential: DataFrame of Float
        :return: An instance of the Equity class
        :rtype: Equity object
    """
    def __init__(self, value=1, return_rate=.01, time_horizon=50, starting_point=1):
        """
            creates an Equity object
        """
        self.starting_point = starting_point
        self.time_horizon = time_horizon
        self.flag = 0

        # Initialisation du return_rate
        self.return_rate = pd.DataFrame(data=0, index=np.arange(1,time_horizon+1), columns=['RRate'])
        self.return_rate.loc[self.starting_point:self.time_horizon, 'RRate'] = return_rate
        # ligne suivante temporaire pour phase de coding/testing:
        self.return_rate.loc[self.starting_point:self.time_horizon, 'RRate'] = np.random.normal(.02, .01, size=self.time_horizon-self.starting_point+1 )
        # Initialisation de value
        self.value = pd.DataFrame(data=value, index=np.arange(1,time_horizon+1), columns=['Market Value', 'Book Value'])
        self.value.loc[:starting_point-1, 'Book Value'] = 0
        self.value.loc[:starting_point-1, 'Market Value'] = 0
        # Initialisation des PGL
        self.potential = pd.DataFrame(data=0, index=np.arange(1,time_horizon+1), columns=['Potential Gain', 'Potential Loss'])
        self.computePotential()         

    def cashOut(self, current_step):
        """
            cashes out the amount of money generated by the Equity
        """
        output = {}
        output['all'] = self.value.loc[current_step, 'Market Value']
        output['pnl'] = self.value.loc[current_step, 'Market Value'] - self.value.loc[current_step, 'Book Value']
        if(current_step<self.time_horizon):
            self.value.loc[np.arange(current_step+1,self.time_horizon+1), 'Market Value'] = 0
            self.value.loc[np.arange(current_step+1,self.time_horizon+1), 'Book Value'] = 0
        self.computePotential()
        return output    
   
    def sell(self, amount, current_step):
        res = 0
        ratio = amount / self.value.loc[current_step, 'Market Value']
        if(ratio <= 1):
            self.value.loc[current_step:self.time_horizon, 'Market Value'] -= ratio \
                * self.value.loc[current_step:self.time_horizon, 'Market Value'] 
            self.value.loc[current_step:self.time_horizon, 'Book Value'] -= ratio \
                * self.value.loc[current_step:self.time_horizon, 'Book Value']
            if(self.value.loc[current_step, 'Book Value'] < 0):
                res = -self.value.loc[current_step, 'Book Value'] # s'il renvoit une valeur>0 = Plus Value, <0 = Moins Value
                self.value.loc[current_step:self.time_horizon, 'Book Value'] = 0
        self.computePotential()
        return res
        
    def getWealth(self, current_step):
        """
            returns the amount of money represented by the Equity at a certain point in time
        """
        return (self.value.loc[current_step, 'Market Value'])

    def getWealthPlus(self, current_step):
        """
            returns the wealth returned by the selling of the Equity increased by the potential gain on it
        """
        return self.getWealth(current_step) + self.potential.loc[current_step, 'Potential Gain']
        
    def getWealthMinus(self, current_step):
        """
            returns the wealth returned by the selling of the Equity decreased by the potential loss on it
        """
        return self.getWealth(current_step) + self.potential.loc[current_step, 'Potential Loss']
#   
    def computePotential(self):
        """
            updates the potential gains & losses on this Equity
        """
        self.potential["Potential Gain"] = np.where(self.value.loc[:, 'Market Value'] - self.value.loc[:, 'Book Value'] >0, \
                      (self.value.loc[:, 'Market Value'] - self.value.loc[:, 'Book Value']), 0)
        self.potential["Potential Loss"] = np.where(self.value.loc[:, 'Market Value'] - self.value.loc[:, 'Book Value'] <0, \
                      (self.value.loc[:, 'Market Value'] - self.value.loc[:, 'Book Value']), 0)

    def updateValue(self, current_step):
        """
            capitalizes the Equity over a period of time
        """
        # no dividend hypothesis
        # non amortizable Asset type i.e. Book Value doesn't decrease over time
        # Market Value updating only
        res = self.value.loc[current_step, 'Market Value'] * self.return_rate.loc[current_step, 'RRate']
        self.value.loc[current_step+1:self.time_horizon, 'Market Value'] = self.value.loc[current_step, 'Market Value'] + res
        return res
        
    def update(self, current_step, current_yield=None, spreads=None):
        """
            updates the Equity over a period of time
        """
        return self.updateValue(current_step)

    def __str__(self):
        return (self.value['Market Value']).__str__()

#--------------------------------------------------
#       Start of the testing part of the code
#--------------------------------------------------

#def main():
#    import gc
#    gc.enable()
#    
#    equity = Equity(value=100)
#    for t in range(1, equity.time_horizon+1):
#        print("t = ",t, "I = ", equity.update(t), "all = ", equity.value.loc[t, 'Market Value''])
##    res =  equity.cashOut(current_step=19)
##    equity2 = Equity(value=res['all'], starting_point=20)
###        if(t>1 and t<50):
###            equity.sell(amount=.001*equity.value.loc[t-1, 'Market Value'], current_step=t)
##    print("End of trajectory value = ", equity.cashOut(equity.time_horizon))
#
#    df = equity.value.plot(title='Evolution de la valeur d\'un Asset au cours de la simulation')
##    equity2.value.plot(ax=df)
##    df.legend(loc='center left', bbox_to_anchor=(1.0, 0.5))
##    
##    df.grid(True)
#    
#if __name__ == "__main__":
#    main()
    